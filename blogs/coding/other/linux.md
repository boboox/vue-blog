---
title: linux常用指令
lang: zh-CN
pageClass: bash-class
---
[[toc]]

# linux常用指令

## grep (Global Regular Expression Print)

- -a   --text   #不要忽略二进制的数据。   
- -A<显示行数>   --after-context=<显示行数>   #除了显示符合范本样式的那一列之外，并显示该行之后- 的内容。   
- -b   --byte-offset   #在显示符合样式的那一行之前，标示出该行第一个字符的编号。   
- -B<显示行数>   --before-context=<显示行数>   #除了显示符合样式的那一行之外，并显示该行之前的- 内容。   
- -c    --count   #计算符合样式的列数。   
- -C<显示行数>    --context=<显示行数>或-<显示行数>   #除了显示符合样式的那一行之外，并显示该行- 之前后的内容。   
- -d <动作> --directories=<动作>   #当指定要查找的是目录而非文件时，必须使用这项参数，否则- grep指令将回报信息并停止动作。   
- -e<范本样式>  --regexp=<范本样式>   #指定字符串做为查找文件内容的样式。   
- -E      --extended-regexp   #将样式为延伸的普通表示法来使用。   
- -f<规则文件>  --file=<规则文件>   #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规- 则条件的文件内容，格式为每行一个规则样式。   
- -F   --fixed-regexp   #将样式视为固定字符串的列表。   
- -G   --basic-regexp   #将样式视为普通的表示法来使用。   
- -h   --no-filename   #在显示符合样式的那一行之前，不标示该行所属的文件名称。   
- -H   --with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。   
- -i    --ignore-case   #忽略字符大小写的差别。   
- -l    --file-with-matches   #列出文件内容符合指定的样式的文件名称。   
- -L   --files-without-match   #列出文件内容不符合指定的样式的文件名称。   
- -n   --line-number   #在显示符合样式的那一行之前，标示出该行的列数编号。   
- -q   --quiet或--silent   #不显示任何信息。   
- -r   --recursive   #此参数的效果和指定“-d recurse”参数相同。   
- -s   --no-messages   #不显示错误信息。   
- -v   --revert-match   #显示不包含匹配文本的所有行。   
- -V   --version   #显示版本信息。   
- -w   --word-regexp   #只显示全字符合的列。   
- -x    --line-regexp   #只显示全列符合的列。   
- -y   #此参数的效果和指定“-i”参数相同。

## ps (Process status)
- -a：显示所有终端机下执行的程序，除了阶段作业领导者之外。
- a：显示现行终端机下的所有程序，包括其他用户的程序。
- -A：显示所有程序。
- -c：显示CLS和PRI栏位。
- c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。
- -C<指令名称>：指定执行指令的名称，并列出该指令的程序的状况。
- -d：显示所有程序，但不包括阶段作业领导者的程序。
- -e：此选项的效果和指定"A"选项相同。
- e：列出程序时，显示每个程序所使用的环境变量。
- -f：显示UID,PPIP,C与STIME栏位。
- f：用ASCII字符显示树状结构，表达程序间的相互关系。
- -g<群组名称>：此选项的效果和指定"-G"选项相同，当亦能使用阶段作业领导者的名称来指定。
- g：显示现行终端机下的所有程序，包括群组领导者的程序。
- -G<群组识别码>：列出属于该群组的程序的状况，也可使用群组名称来指定。
- h：不显示标题列。
- -H：显示树状结构，表示程序间的相互关系。
- -j或j：采用工作控制的格式显示程序状况。
- -l或l：采用详细的格式来显示程序状况。
- L：列出栏位的相关信息。
- -m或m：显示所有的执行绪。
- n：以数字来表示USER和WCHAN栏位。
- -N：显示所有的程序，除了执行ps指令终端机下的程序之外。
- -p<程序识别码>：指定程序识别码，并列出该程序的状况。
- p<程序识别码>：此选项的效果和指定"-p"选项相同，只在列表格式方面稍有差异。
- r：只列出现行终端机正在执行中的程序。
- -s<阶段作业>：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。
- s：采用程序信号的格式显示程序状况。
- S：列出程序时，包括已中断的子程序资料。
- -t<终端机编号>：指定终端机编号，并列出属于该终端机的程序的状况。
- t<终端机编号>：此选项的效果和指定"-t"选项相同，只在列表格式方面稍有差异。
- -T：显示现行终端机下的所有程序。
- -u<用户识别码>：此选项的效果和指定"-U"选项相同。
- u：以用户为主的格式来显示程序状况。
- -U<用户识别码>：列出属于该用户的程序的状况，也可使用用户名称来指定。
- U<用户名称>：列出属于该用户的程序的状况。
- v：采用虚拟内存的格式显示程序状况。
- -V或V：显示版本信息。
- -w或w：采用宽阔的格式来显示程序状况。　
- x：显示所有程序，不以终端机来区分。
- X：采用旧式的Linux i386登陆格式显示程序状况。
- -y：配合选项"-l"使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。
- -<程序识别码>：此选项的效果和指定"p"选项相同。
- --cols<每列字符数>：设置每列的最大字符数。
- --columns<每列字符数>：此选项的效果和指定"--cols"选项相同。
- --cumulative：此选项的效果和指定"S"选项相同。
- --deselect：此选项的效果和指定"-N"选项相同。
- --forest：此选项的效果和指定"f"选项相同。
- --headers：重复显示标题列。
- --help：在线帮助。
- --info：显示排错信息。
- --lines<显示列数>：设置显示画面的列数。
- --no-headers：此选项的效果和指定"h"选项相同，只在列表格式方面稍有差异。
- --group<群组名称>：此选项的效果和指定"-G"选项相同。
- --Group<群组识别码>：此选项的效果和指定"-G"选项相同。
- --pid<程序识别码>：此选项的效果和指定"-p"选项相同。
- --rows<显示列数>：此选项的效果和指定"--lines"选项相同。
- --sid<阶段作业>：此选项的效果和指定"-s"选项相同。
- --tty<终端机编号>：此选项的效果和指定"-t"选项相同。
- --user<用户名称>：此选项的效果和指定"-U"选项相同。
- --User<用户识别码>：此选项的效果和指定"-U"选项相同。
- --version：此选项的效果和指定"-V"选项相同。
- --widty<每列字符数>：此选项的效果和指定"-cols"选项相同。

```bash
ps aux
```
- 显示现行终端机下的所有程序，包括其他用户的程序。
- 以用户为主的格式来显示程序状况。
- 显示所有程序，不以终端机来区分。


```bash
ps -aux
```
这个命令会报错,因为-u 之后需要指定uid


```bash
ps -ax
```
- 示所有终端机下执行的程序，除了阶段作业领导者之外。
- 显示所有程序，不以终端机来区分。

因为当-x不被识别的时候按照x参数处理









## 任务相关指令

### & 

加载一个命令的最后面,可以把一个命令放到后台去执行

### ctrl+z

将当前在前台执行的命令放到后台去并且处于暂停状态

### jobs

查看当前有多少在后台运行的命令

- -l 显示pid

任务的状态
- running
- stopped
- terminated

### fg

将后台中的命令调至前台继续运行,如果后台中有多个命令,
可以使用jobs %jobNumber(命令的编号,不是pid,[1]+中的1)

### bg

将一个在后台暂停的命令变成在后台继续执行

### kill

结束job或者进程

kill [jobNumber|pid]

### nohup

不挂断的运行命令,可以指定日志输出路径,不指定则输入的当前目录的nohup.out
```bash
nohup xxxxx
```
后台运行,不会被ctrl+c 打断,不接受输入
```bash
nohup xxx &
```

命令输入到终端
将输入定向到xxx.txt文件中
```bash
nohup xxx > xxx.txt
```

将输出的标准输出与标准错误分开输出到不同的文件

```bash
nohup xxx 1 > stdout.out 2 > stderr.out &
```

输入到同一个文件
```bash
nohup xxx > std.out 2>&1 
```
这个命令等同于
```bash
nohup xxx 1 > std.out 2 > std.out
```
区别是 后者会打开两次std.out.而且标准错误会把标准输入覆盖,
前者只打开一次std.out




- 

## type:查询是否为内建命令





