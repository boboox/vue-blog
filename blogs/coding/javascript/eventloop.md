---
title: JS的事件循环机制
---

# JS的事件循环机制

文章大部分内容引用[详解JavaScript中的Event Loop（事件循环）机制][ref]

## 单线程,非阻塞

javascript从诞生之日起就是一门单线程的非阻塞的脚本语言

**单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。**

**而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。**

***现如今人们也意识到，单线程在保证了执行顺序的同时也限制了javascript的效率，因此开发出了web worker技术。这项技术号称让javascript成为一门多线程语言。***

***然而，使用web worker技术开的多线程有着诸多限制，例如：所有新线程都受主线程的完全控制，不能独立执行。这意味着这些“线程” 实际上应属于主线程的子线程。另外，这些子线程并没有执行I/O操作的权限，只能为主线程分担一些诸如计算等任务。所以严格来讲这些线程并没有完整的功能，也因此这项技术并非改变了javascript语言的单线程本质。***

js引擎就是通过**Event Loop**来实现这一点

## 执行栈与事件队列

### 执行栈
当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 

当我们调用一个方法的时候,js会生成一个与这个方法对于的[执行环境(context)][excutecontext]又称执行上下文.这个上下文包含了
- 方法的私有作用域
- 上层作用域的指向
- 方法的参数
- 作用域中定义的变量
- 作用域的this对象的绑定

但是当一系列方法被依次调用的时候,
由于js是单线程,同一时间只能执行一个方法,所以这些方法会依次被排队在一个被称为`执行栈`的地方

![执行栈](~@img/coding/javascript/excute-stack.gif)

(所以当遇到递归或者死循环的情况下经常会发生栈溢出的异常,这个栈就是指的`执行栈`,执行栈的上限依不同浏览器而定)

<span style='color:red'>记住执行栈,有五个关键点</span>

1. 单线程
2. 同步执行
3. 一个全局环境
4. 无限的函数环境
5. 函数被调用就会创建一个新的执行环境，甚至调用自己。 

### 事件队列

执行栈所说的都是同步代码的执行,那么当一个异步代码(Ajax,Promise)执行后又是如何?这里便提现了js的非阻塞的特性

js非阻塞特性的实现所依赖的机制就是`事件队列(Task Queue)`

当js遇到异步事件后并不会等待起结果返回,而是会将这个事件挂起,继续执行`执行栈`中的其他任务,
当一个异步事件返回结果后,js会将这个事件放入与当前`执行栈`不同的另一个队列,这个事件称为`事件队列(Task Queue)`
当主线程处于`闲置`状态的时候,主线程回去查找事件队列是否有任务.如果有,主线程则会取出其中排第一的事件并把这个事件的回调函数放入执行栈中,然后执行.这个循环的就叫做`事件循环(Event Loop)`

![执行栈](~@img/coding/javascript/event-loop.jpg)

- stack即执行栈
- callback queue即事件队列

### 异步任务

异步任务之间并不相同,他们的优先级也有区别,异步任务分为两类

- 微任务(micro task) (高优先级)
    - Promise()
    - MutationObserver()
- 宏任务(macro task)
    - setInterval()
    - setTimeout()

::: tip 注意
当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。
:::




[ref]: https://zhuanlan.zhihu.com/p/33058983  "详解JavaScript中的Event Loop（事件循环）机制"
[excutecontext]: ./excute-context.html 
