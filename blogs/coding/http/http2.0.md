---
title: http2.0
---

# http2.0

[[toc]]

## 什么是http2.0

HTTP 2.0是在SPDY（An experimental protocol for a faster web, The Chromium Projects）基础上形成的下一代互联网通信协议。HTTP/2 的目的是通过支持请求与响应的多路复用来较少延迟，通过压缩HTTPS首部字段将协议开销降低，同时增加请求优先级和服务器端推送的支持。

## 二进制分帧层

二进制分帧层是http/2的性能增强的核心

http 1.x在应用层以纯文本的形式进行通信,而http 2.0将所有的传输信息分割为更小的消息和帧,并对他们采用二进制格式编码.
这样,客户端与服务端都需要引入新的二进制编码和解码的机制.
如下图
![二进制分帧层](~@img/coding/http/http2-frame.png)

### 帧

在http1.x时代我们习惯与head和body打交道,到了2.0时代,取而代之的是帧(frame),
它将成为协议中的最小通信单位(未改变http的语义),所有的head和body都会打包到帧内发送

帧又分为
- header frame(头部帧)
- data frame(数据帧)

帧的开头9个byte(72bit),后续为payload

结构见
```bash
 +-----------------------------------------------+
 |                 Length (24)                   |
 +---------------+---------------+---------------+
 |   Type (8)    |   Flags (8)   |
 +-+-------------+---------------+-------------------------------+
 |R|                 Stream Identifier (31)                      |
 +=+=============================================================+
 |                   Frame Payload (0...)                      ...
 +---------------------------------------------------------------+
```
frame定义如下

 - **Length** :帧主体长度。24 bits unsigned int
    - 无符号的自然数，24个比特表示，仅表示帧负载（Frame Payload）所占用字节数，不包括帧头所占用的9个字节。默认大小区间为为0~16,384(2^14)，一旦超过默认最大值2^14(16384)，发送方将不再允许发送，除非接收到接收方定义的SETTINGS_MAX_FRAME_SIZE（一般此值区间为2^14 ~ 2^24）值的通知。
 - **Type** ： 类型(8 bits)。
    - 8个比特表示，定义了帧负载的具体格式和帧的语义，HTTP/2规范定义了10个帧类型，这里不包括实验类型帧和扩展类型帧
    - DATA            0x0   用于传输HTTP消息体
    - HEADERS         0x1   用于传输首部字段
    - PRIORITY        0x2   用于指定或重新指定引用资源的优先级。
    - RST_STREAM      0x3   用于通知流的非正常终止。
    - SETTINGS        0x4   用于约定客户端和服务端的配置数据。比如设置初识的双向流量控制窗口大小
    - PUSH_PROMISE    0x5   服务端推送许可。
    - PING            0x6   用于计算往返时间，执行“ 活性” 检活。
    - GOAWAY          0x7   用于通知对端停止在当前连接中创建流。
    - WINDOW_UPDATE   0x8   用于调整个别流或个别连接的流量
    - CONTINUATION    0x9
 - **Flags** ： 特定的Type，有一组特定的flag，以便对type做更多约定 
 - **R** : 保留(1bit)。语义未设置并且必须在发送的时候设置为 0
 - **Stream Identifier** : 流标识符(31 bytes）。
    - HTTP2场景下，TCP Connection不再只有一对请求+响应了——可以有多个响应。这些响应打包到多个Frame，在一个 Connection 上混合交错的发。接收方必须知道每个Frame属于那个Response，这就是流所标示的了。

### 消息

消息是指逻辑上的HTTP消息（请求/响应）。一系列数据帧组成了一个完整的消息。比如一系列DATA帧和一个HEADERS帧组成了请求消息。

### 流

流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。 
所有HTTP 2. 0 通信都在一个TCP连接上完成， 这个连接可以承载任意数量的双向数据流Stream。 相应地， 每个数据流以 消息的形式发送， 而消息由一 或多个帧组成，**这些帧可以乱序发送， 然后根据每个帧首部的流标识符重新组装。**

二进制分帧层保留了HTTP的语义不受影响，包括首部、方法等，在应用层来看，和HTTP 1.x没有差别。同时，所有同主机的通信能够在一个TCP连接上完成。

## 多路复用共享链接

基于二进制分帧层,http2.0可以在共享tcp的基础上,同时发起请求和响应.
http消息被分解成独立的帧,
而不破坏本身的语义,交错的发送,**最后在另一端根据流标识(Stream Identifier)和首部将他们重新组合起来**

对比于http1.x,2.0的性能的提升显而易见,
有效的解决了1.x的队首阻塞问题.(除了tcp层的阻塞仍然无法解决)
同时也不需要通过pipeline机制建立多条TCP连接来实现并行请求与响应

减少了TCP连接数,对服务器的性能也有了很大的提升

## 请求优先级

用帧类型为 PRIORITY 来标记优先级
????

## 服务器推送

HTTP 2.0增加了服务端推送功能，服务端可以根据客户端的请求，提前返回多个响应，推送额外的资源给客户端。

帧类型为PUSH_PROMISE的帧是服务端向客户端准备推送资源的信号

- 如果客户端不需要服务器端PUSH,可以在SETTINGS帧中设定服务端流的值为0,禁用次功能
- PUSH_PROMISE帧中只包含预推送资源的首部。如果客户端对PUSH_PROMISE帧没有意见，服务端在PUSH_PROMISE帧后发送响应的DATA帧开始推送资源。如果客户端已经缓存该资源，不需要再推送，可以选择拒绝PUSH_PROMISE帧
- PUSH_PROMISE必须遵循请求-响应原则，只能借着对请求的响应推送资源。 
    - apache的mod_http2能够开启h2push on服务端Push
    - nginx在1.13.9版本加入了服务端push功能[Nginx实现http2服务器端推送](https://www.hi-linux.com/posts/9911.html)

## 首部压缩

HTTP1.X每一次通信都会携带首部信息用于描述资源属性.
HTTP2.0在客户端和服务端之间使用"首部表"来跟踪和存储之前发送的键值对.
首部表在链接过程中始终存在,新增的键值对会更新到表尾,因此不需要每次通信都携带首部

同时,HTTP2.0使用了首部压缩技术(HPACK算法)不同于body的GZIP等算法,两者不冲突

## 基于完整http/2的通信过程

对于服务器端是否支持HTTP2.0,是否支持二进制分帧的解码与编码.
两端在进行HTTP2.0通信之前,存在一个`协议协商`的过程

### 基于ALPN的协商过程

ALPN(Application Layer Protocol Negotiation)应用层协议协商

支持HTTP2.0的浏览器可以在TLS会话层自发完成和服务端的协议协商以确定是否可以使用HTTP2.0通信.

服务端使用ALPN 监听443端口,默认HTTP1.1允许协商其他协议,比如SPDY和HTTP2.0

### 基于HTTP的协商过程

通过HTTP Upgrade机制(OKHTTP,NGHTTP2等组件可以实现)通过协商确定适当的协议

### 完整通信过程

在chrome中`chrome://net-internals/#http2`命令也能捕获HTTP 2.0通信过程

## HTTP/2性能瓶颈

????
